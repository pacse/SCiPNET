from os import get_terminal_size as gts
from urllib.parse import unquote
from rich.markdown import Markdown as Md
from rich.console import Console
from rich.text import Text
from time import sleep as sp
from random import uniform as uf
#from tabulate import tabulate
def tabulate(*args, **kwags):
    return ""

from .basic import clear, timestamp
from .sql import init_scp, User, SCP, Site, MTF, get_name, init_site, init_mtf, init_usr

# disable markdown_it logging
import logging
logging.getLogger("markdown_it").setLevel(logging.WARNING)

# for typdefing
from typing import Any

''' Validate terminal size '''
try:
    SIZE = gts().columns
    SIZE = SIZE if SIZE % 2 == 0 else SIZE-1  # type: ignore
except OSError:
    SIZE = 120 # type: ignore

if SIZE < 120:
    raise Exception(f"Requires terminal size of 120 columns (current size {SIZE})")

# useful str bars (ACS, Site, etc.)
REPEATED = "═" * 58


def printc(string: str) -> None:
  '''
  prints {string} centered to the terminal size
  '''
  print(f"{string:^{SIZE}}")

def print_lines(lines: list[str]) -> None:
    '''
    printc's all lines provided
    '''
    for line in lines:
        printc(line)


def startup() -> None:
    '''
    Prints a fancy startup screen

    (Ascii art generated by ChatGPT & patorjk.com/software/taag/ Font: ANSI Shadow)
    '''
    clear()

    # main terminal screen
    print()
    printc("███▀▀▀▀███▀▀▀▀███▀▀▀▀███▀▀▀▀███▀▀▀▀███▀▀▀▀███▀▀▀▀███▀▀▀▀███▀▀▀▀███▀▀▀▀███▀▀▀▀███▀▀▀▀███▀▀▀▀███▀▀▀▀███▀▀▀▀███▀▀▀▀███▀")
    printc("███████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓███████")
    printc("██ ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ ░░ ██")
    print()
    printc("███████╗ ██████╗██████╗     ███████╗ ██████╗ ██╗   ██╗███╗   ██╗██████╗  █████╗ ████████╗██╗ ██████╗ ███╗   ██╗")
    printc("██╔════╝██╔════╝██╔══██╗    ██╔════╝██╔═══██╗██║   ██║████╗  ██║██╔══██╗██╔══██╗╚══██╔══╝██║██╔═══██╗████╗  ██║")
    printc("███████╗██║     ██████╔╝    █████╗  ██║   ██║██║   ██║██╔██╗ ██║██║  ██║███████║   ██║   ██║██║   ██║██╔██╗ ██║")
    printc("╚════██║██║     ██╔═══╝     ██╔══╝  ██║   ██║██║   ██║██║╚██╗██║██║  ██║██╔══██║   ██║   ██║██║   ██║██║╚██╗██║")
    printc("███████║╚██████╗██║         ██║     ╚██████╔╝╚██████╔╝██║ ╚████║██████╔╝██║  ██║   ██║   ██║╚██████╔╝██║ ╚████║")
    printc("╚══════╝ ╚═════╝╚═╝         ╚═╝      ╚═════╝  ╚═════╝ ╚═╝  ╚═══╝╚═════╝ ╚═╝  ╚═╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝")
    printc("Secure | Contain | Protect")
    print()
    printc("— [ ACCESS PORTAL: SCiPNET TERMINAL v7.23.4 ] —")
    printc("██ ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ ░░ ██")
    printc("███████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓███████")
    printc("███▄▄▄▄███▄▄▄▄███▄▄▄▄███▄▄▄▄███▄▄▄▄███▄▄▄▄███▄▄▄▄███▄▄▄▄███▄▄▄▄███▄▄▄▄███▄▄▄▄███▄▄▄▄███▄▄▄▄███▄▄▄▄███▄▄▄▄███▄▄▄▄███▄")
    print()

    # simulate loading (bc it's cool)
    sp(uf(0, 1))
    printc("> Establishing encrypted tunnel to Deepwell Servers . . .")
    sp(uf(0, 1))
    printc("> Syncing with Recordkeeping And Information Security Administration (RAISA) . . .")
    sp(uf(0, 1))
    printc("> Validating cryptographic token . . .")
    sp(uf(0, 1))
    printc("> SCiPNET interface launch sequence initiated . . .")
    sp(uf(0, 1))
    printc("SCP Foundation CoreNode Connection: STABLE")
    print()
    sp(uf(0, 1))
    printc("[The Foundation database is CLASSIFIED]")
    printc("[Unauthorized access will result in detainment]")
    print()


def login(usr: User) -> None:
    '''
    prints fancy login messages when
    a user logs in.

    Art by ChatGPT
    '''
    # lines we'll use a few times
    reused1 = "/" * 4 + " " * 112 + "/" * 4
    reused2 = "/" * 120
    title = get_name("titles", usr.title_id)

    # set lines depending on usr title
    if title == "O5 Council Member":
        lines = [
            "",
            reused2,
            reused1,
            "////" + f"{'<< O5 AUTHORIZATION VERIFIED >>':^112}" + "////",
            reused1,
            "////" + f"{'CLEARANCE LEVEL: 6 - COSMIC TOP SECRET':^112}" + "////",
            reused1,
            "////" + f"{f'Welcome back, {usr.name}.':^112}" + "////",
            "////" + f"{f'This session is being logged by CoreNode Zero.':^112}" + "////",
            reused1,
            "////" + f"{'SYSTEM STATUS: OPERATIONAL | DEEPWELL CHANNEL ENCRYPTED':^112}" + "////",
            reused1,
            reused2,
            "",
        ]

    elif title == "Site Director":
        lines = [
            "",
            reused2,
            reused1,
            "////" + f"{'<< DIRECTOR AUTHORIZATION VERIFIED >>':^112}" + "////",
            reused1,
            "////" + f"{'CLEARANCE LEVEL: 5 - TOP SECRET':^112}" + "////",
            reused1,
            "////" + f"{f'Welcome back, {usr.name}.':^112}" + "////",
            "////" + f"{'All actions are recorded and reviewed by O5 Liaison - Node Black':^112}" + "////",
            reused1,
            "////" + f"{'SYSTEM STATUS: OPERATIONAL | DEEPWELL CHANNEL ENCRYPTED':^112}" + "////",
            reused1,
            reused2,
            "",
        ]

    elif title == "Administrator":
        lines = [
            "",
            reused2,
            reused1,
            "////" + f"{'<< ADMINISTRATOR AUTHORIZATION VERIFIED >>':^112}" + "////",
            reused1,
            "////" + f"{'CLEARANCE LEVEL: UNBOUNDED | OVERRIDE: UNIVERSAL | LOGGING: DISABLED':^112}" + "////",
            reused1,
            "////" + f"{'Welcome, Administrator. All systems stand by for your instruction.':^112}" + "////",
            "////" + f"{'There are no restrictions. There are no records.':^112}" + "////",
            reused1,
            "////" + f"{'SYSTEM STATUS: OPERATIONAL | ENCLAVE MODE ACTIVE':^112}" + "////",
            reused1,
            reused2,
            "",
        ]

    else:
        lines = [
            "",
            f"Welcome back, {title} {usr.name}",
            f"(Clearance Level {usr.clearance_level_id} - {get_name('clearance_levels', usr.clearance_level_id)})"
            "",
        ]

    print_lines(lines)


def redacted(file: str, file_classification: int, clearance: int) -> None:
    '''
    prints a message saying {file} is above your clearance

    art by ChatGPT
    '''
    print_lines([
        "",
        "╔══════════════════════════════╗",
        "║        ACCESS DENIED         ║",
        "╚══════════════════════════════╝",
        "",
        f"FILE_REF: {file} REDACTED",
        f"CLEARANCE {get_name('clearance_levels', file_classification).upper()} REQUIRED",
        f"(YOU ARE CLEARANCE {get_name('clearance_levels', clearance).upper()})",
        f"Logged to RAISA at {timestamp()}",
        "",
    ])

def expunged(file: str) -> None:
    '''
    prints a message saying {file} has been expunged

    art by ChatGPT
    '''
    print_lines([
        "",
        "╔══════════════════════════════╗",
        "║        DATA EXPUNGED         ║",
        "╚══════════════════════════════╝",
        "",
        f"FILE_REF: {file} NOT FOUND",
        f"Logged to RAISA at {timestamp()}",
        "",
    ])

def granted(file: str) -> None:
    '''
    prints a message saying access has been granted to a file

    art by ChatGPT
    '''
    print_lines([
        "",
        "╔══════════════════════════════╗",
        "║        ACCESS GRANTED        ║",
        "╚══════════════════════════════╝",
        "",
        f"FILE_REF: {file} ACCESS GRANTED",
        f"Logged to RAISA at {timestamp()}",
        "",
    ])


def create_f(f_type: str) -> None:
    '''
    Prints a simple message for file creation

    art by ChatGPT
    '''
    print_lines([
        "",
        "╔══════════════════════════════╗",
        "║         FILE CREATION        ║",
        "╚══════════════════════════════╝",
        "",
        f"{f_type}",
        "",
    ])

def clearance_denied(needed_c: int, usr_c: int) -> None:
    '''
    Tells the usr they have insufficient clearance for file creation

    art by ChatGPT
    '''
    print_lines([
        "",
        "╔══════════════════════════════╗",
        "║     INSUFFICIENT CLEARANCE   ║",
        "╚══════════════════════════════╝",
        ""
        f"CLEARANCE {get_name('clearance_levels', needed_c).upper()} REQUIRED TO CREATE FILE",
        f"(YOU ARE CLEARANCE {get_name('clearance_levels', usr_c).upper()})",
        f"Logged to RAISA at {timestamp()}",
        "",
    ])

def invalid_f_type(f_type: str) -> None:
    '''
    Tells a user that {f_type} is not a valid f_type
    '''
    print_lines([
        "",
        "╔══════════════════════════════╗",
        f"║{'INVALID FILE TYPE':^30}║",
        "╚══════════════════════════════╝",
        ""
        f"{f_type.upper()} IS NOT A VALID FILE TYPE",
        f"Logged to RAISA at {timestamp()}",
        "",
    ])

def invalid_f_data() -> None:
    '''
    Tells a user that the file data is invalid
    '''
    print_lines([
        "",
        "╔════════════════════════════════════════╗",
        "║            INVALID FILE DATA           ║",
        "╚════════════════════════════════════════╝",
        "",
        f"Logged to RAISA at {timestamp()}",
        "",
    ])

def no_data_recvd() -> None:
    '''
    Tells a user that the server received no data

    Art by ChatGPT
    '''
    print_lines([
        "",
        "╔════════════════════════════════════════╗",
        f"║{'SERVER RECEIVED NO DATA':^40}║",
        "╚════════════════════════════════════════╝",
        "",
        "CONTACT YOUR SITE NETWORK ADMINISTRATOR IF ISSUES PERSIST",
        f"Logged to RAISA at {timestamp()}",
        "",
    ])

def no_response() -> None:
    '''
    Tells usr that no response was received from the server

    art by ChatGPT, formatting by me
    '''
    print_lines([
        "",
        "╔════════════════════════════════════════╗",
        f"║{'ERROR: NO RESPONSE FROM':^40}║",
        "║                DEEPWELL                ║",
        "╚════════════════════════════════════════╝",
        "",
        "PLEASE TRY AGAIN",
        "CONTACT YOUR SITE NETWORK ADMINISTRATOR IF ISSUES PERSIST",
        f"Logged to RAISA at {timestamp()}",
        "",
    ])

def created_f(f_type: str) -> None:
    '''
    prints a message saying a file was successfully created

    art by ChatGPT
    '''
    print_lines([
        "",
        "╔══════════════════════════════╗",
        "║            CREATED           ║",
        "╚══════════════════════════════╝",
        "",
        f"{f_type} INITIALIZED",
        f"Logged to RAISA at {timestamp()}",
        "",
    ])


def print_piped_line(console: Console, 
                     string: str, 
                     side: str,
                     hex_colour: int | None = None,
                     width = 58,
                     outer_space = (SIZE - 120) // 2,
                     default_colouring = True) -> None:
    
    # quick input validation
    assert side in ["l", "r", "c"], f"Invalid side choice {side!r}. Must be 'l' or 'r'"

    # calculate inner space
    inner_space = (width - len(string)) // 2
    
    # do we need extra space?
    if inner_space * 2 != (width - len(string)):
        use_extra = True
    else:
        use_extra = False
    
    # print left space
    if side == 'l':
        print(f"{(' ' * outer_space)}║{' ' * inner_space}", end="")

        # extra space for centring
        if use_extra:
            print(" ",end="")
            # flip use extra (saves time later)
            use_extra = not use_extra
    else:
        print(f"║{' ' * inner_space}",end="")
        
    # start printing main line
    split_string = string.split(":") # we only format after the colon
    print(f"{split_string[0]}:", end="")
    
    # now's the hard part, format

    # first get everything we want to format
    f_string = "".join(split_string[1:])
    
    # if we're not using default colouring, 
    # just print bold f_string
    if not default_colouring:
        f_string = Text(f_string)
        console.print(f_string, style = "bold", end="")
    
    # disable normal colouring if we have a hex_code
    elif hex_colour:
        f_string = Text(f_string)
        console.print(f_string, style = f"#{hex_colour:06x} bold", end="")
    
    # otherwise just bold
    else:
        console.print(f_string, style = "bold",end="")
    
    # ╰(*°▽°*)╯ yeye that wasn't that hard ╰(*°▽°*)╯
    # now rest of line
    
    # print right space
    print(f"{' ' * inner_space}{' ' if use_extra else ''}", end="")
    
    # now do we move to a newline?
    if side == "r":
        print("║")


def print_table(data: list[dict[str,str]]) -> None:

    # Generate table with tabulate
    table_str = tabulate(
        data,
        headers="keys",
        tablefmt="fancy_grid",
        stralign="center"
    )

    # format table
    table_str = (
                table_str
                .replace("│","║").replace("╡","╣")
                .replace("╞","╠").replace("├","╟")
                .replace("┤","╢").replace("╪","╬")
                .replace("┼","╫").replace("╛","╝")
                .replace("╘","╚").replace("╧","╩")
                .replace("╕","╗").replace("╒","╔")
                .replace("╤","╦").split("\n")
                )

    # print
    for line in table_str:
        print(line)
    

# To display an SCP
def acs_bar(scp_info: SCP, console: Console) -> None:
    '''
    prints a ACS header for an scp article

    art by ChatGPT
    '''
    site_responsible = scp_info.site_responsible_id if scp_info.site_responsible_id else "[REDACTED]"

    print()
    printc(f"╔{REPEATED}╦{REPEATED}╗")
    print_piped_line(console, f"Item #: SCP-{scp_info.id:03d}", "l", default_colouring=False)
    print_piped_line(console, f"Classification Level: {scp_info.classification_level}", "r", scp_info.colours.class_lvl)
    printc(f"╠{REPEATED}╬{REPEATED}╣")
    print_piped_line(console, f"Containment Class: {scp_info.containment_class}", "l", scp_info.colours.cont_clss)
    print_piped_line(console, f"Disruption Class: {scp_info.disruption_class}", "r", scp_info.colours.disrupt_clss)
    print_piped_line(console, f"Secondary Class: {scp_info.secondary_class}", "l", default_colouring=False)
    print_piped_line(console, f"Risk Class: {scp_info.risk_class}", "r", scp_info.colours.rsk_clss)
    printc(f"╠{REPEATED}╬{REPEATED}╣")
    if scp_info.site_responsible_id:
        print_piped_line(console, f"Site Responsible: Site-{scp_info.site_responsible_id}", "l", default_colouring=False)
    else:
        print_piped_line(console, f"Site Responsible: [REDACTED]", "l", default_colouring=False)
    print_piped_line(console, f"Assigned MTF: {scp_info.assigned_task_force_name}", "r", default_colouring=False)
    printc(f"╚{REPEATED}╩{REPEATED}╝")
    print()

def display_scp(data: dict[str, Any], console: Console) -> None:
    '''
    Displays a scp after requested by user
    '''
    scp_info = init_scp(data["db_info"])
    desc: str = data["desc"]
    cps: str = data["cps"]
    addenda: dict[str, str] = data["addenda"]

    # print scp_info
    acs_bar(scp_info, console)

    # print Special Containment Procedures
    md = Md(f"## Special Containment Procedures\n\n{cps}")
    console.print(md)

    # print description
    md = Md(f"## Description\n\n{desc}")
    console.print(md)

    # allow other file showing
    if addenda:
        a_names: list[str] = [key for key in addenda.keys()]
    else:
        a_names = []

    while True: # always offer more addenda after file access

        # make type checking happy
        i = 0
        j = 0
        k = 0

        # spacing between last print
        print()

        # check for remaining addenda
        if a_names:  
            print("Display additional addenda?")

            # offer more addenda
            for i, name in enumerate(a_names):
                print(f"{i}: {unquote(name)}") # name is fname, so quoted

        print("C: close file")

        inp = input("> ")

        # process decesion
        try:
            if inp.upper() == "C":
                return
            else:
                # get file index
                idx = int(inp)

                # access file & print
                name = a_names[idx]
                console.print(Md(f"## {unquote(name)}\n\n{addenda[name]}"))

                # don't offer it again
                a_names.remove(name)
                i -= 1

        except ValueError or IndexError:
            print(f"INVALID CHOICE: {inp!r}")


# To display a site
def site_bar(site_info: Site, site_loc: str, console: Console) -> None:
    print()
    printc(f"╔{REPEATED}═{REPEATED}╗")
    printc(f"║{site_info.name:^117}║")
    printc(f"╠{REPEATED}═{REPEATED}╣")
    print_piped_line(console, f"ID: {site_info.id}", "l", width=28, default_colouring=False)
    print_piped_line(console, f"Director: {site_info.director}", "c", width=29, default_colouring=False)
    print_piped_line(console, f"Location: {site_loc}", "r", default_colouring=False)
    printc(f"╚{REPEATED}═{REPEATED}╝")
    print()

def display_site(data: dict[str, Any], console: Console) -> None:
    '''
    Displays a site after requested by user
    '''
    site_info = init_site(data["db_info"])
    site_loc = data["loc"]
    site_desc = data["desc"]

    # stuff we show later
    keys = []
    for key in data.keys():
        if key not in ["db_info","loc","desc"] and data[key]:
            keys.append(key)


    # first display the site bar
    site_bar(site_info, site_loc, console)

    console.print(Md(f"## Description\n\n{site_desc}"))

    while True: # offer what we can show till f-close

        print() # spacing
        print("Display addditional files?") if keys else print(end="")

        for i in range(len(keys)):
            print(f"{i}: {keys[i]}")
            
        print("C: close file")

        # get usr chice
        choice = input("> ")

        # handle choice
        if choice.upper() == "C":
            return
        
        try:
            name = keys[int(choice)]
            console.print(Md(f"## {name}\n\n{data[name]}"))
            keys.remove(name)

        except ValueError or IndexError:
            continue


# To display a MTF
def mtf_bar(mtf_info: MTF, console: Console) -> None:
    print()
    printc(f"╔{REPEATED}═{REPEATED}╗")
    printc(f"║{f'MTF {mtf_info.name} {mtf_info.nickname!r} (MTF ID: {mtf_info.id})':^117}║")
    printc(f"╠{REPEATED}═{REPEATED}╣")
    print_piped_line(console, f"Assigned Site: Site-{mtf_info.site_id:02d}", "l", width=40, default_colouring=False)
    print_piped_line(console, f"Leader: {mtf_info.leader_name} (Personnel ID: {mtf_info.leader_id})", "c", width=51, default_colouring=False)
    print_piped_line(console, f"Active: {'Yes' if mtf_info.active else 'No'}", "r", width=25, default_colouring=False)
    printc(f"╚{REPEATED}═{REPEATED}╝")
    print()

def display_mtf(data: dict[str, Any], console: Console) -> None:
    '''
    displays a MTF after a user 
    receives MTF info from deepwell
    '''
    mtf_info = init_mtf(data["db_info"])
    mission = data["mission"]
    
    # as always, display the bar first
    mtf_bar(mtf_info, console)

    # now print description
    console.print(Md(f"## Mobile Task Force Mission\n\n{mission}"))

    # and that's it!
    print()


# to display a user
def user_bar(user_info: User, console: Console) -> None:
    print()
    printc(f"╔{REPEATED}═{REPEATED}╗")
    printc(f"║{f'{user_info.title_name} {user_info.name} (ID: {user_info.id})':^117}║")
    printc(f"╠{REPEATED}═{REPEATED}╣")
    print_piped_line(console, f"Assigned Site: Site-{user_info.site_id:02d}", "l", default_colouring=False)
    print_piped_line(console, f"Clearance Level: {user_info.clearance_level_name}", "r", default_colouring=False)
    printc(f"╚{REPEATED}═{REPEATED}╝")
    print()


def display_user(data: dict[str, Any], console: Console) -> None:
    # just a bar for now, no other files
    user_bar(init_usr(data["db_info"]), console)